---
title: "Why Your SaaS Needs an Internal Ops Console (And How We Built Ours)"
description: "How Gigaviz built a 26-page internal ops console for platform administration — from god-mode workspace management to real-time health monitoring, and the security patterns that keep it safe."
date: "2026-02-15"
tags: ["SaaS", "Ops Console", "Admin Panel", "Internal Tools", "Security", "Multi-Tenant", "Platform Engineering"]
published: true
---

# Why Your SaaS Needs an Internal Ops Console (And How We Built Ours)

Every SaaS platform eventually reaches the point where you need to look inside the machine. A customer reports a billing issue. A webhook stops firing. A workspace hits a rate limit and you need to know why.

You could query the database directly. But that doesn't scale when you have a team, and it certainly doesn't create an audit trail.

At Gigaviz, we built a dedicated **ops console** — a 26-page internal admin interface that gives our team full visibility and control without touching raw SQL.

Here's what we learned building it.

## The case for a dedicated ops console

### It's not just "admin panel"

Most SaaS tools bolt on a basic admin panel — a list of users, maybe some settings toggles. An ops console goes further:

- **God Console**: Full workspace management with impersonation, suspension, and entitlement overrides
- **Health Monitoring**: Real-time checks on database, queues, workers, and external APIs
- **Developer Tools**: SQL runner (read-only, whitelisted tables), webhook debugger, API playground, feature flags
- **Support Tools**: Customer search, support tickets with SLA tracking, canned responses
- **Business Intelligence**: Analytics dashboard, data exports (CSV/JSON), saved reports

### Security is non-negotiable

An ops console with write access to every workspace is a **nuclear button**. We implemented multiple layers:

1. **Environment kill switch** (`OPS_ENABLED` env var) — disable the entire console instantly
2. **Layout-level auth guard** — `requirePlatformAdmin()` runs on every page
3. **Owner email allowlist** — only emails in `GIGAVIZ_OWNER_EMAILS` can claim admin access
4. **Rate limiting** — 30 requests per 60 seconds via Upstash Redis
5. **Full audit trail** — every mutation logged with actor, before/after snapshots, and timestamps
6. **Impersonation alerts** — Slack/Discord notifications when an admin impersonates a workspace

## Architecture decisions

### Per-page shell, not layout shell

We render `OpsShell` (nav + header) in each page rather than in `layout.tsx`. Why?

```tsx
// Each page controls its own shell
export default async function WorkspacesPage() {
  const admin = await requirePlatformAdmin();
  if (!admin.ok) redirect("/");
  
  return (
    <OpsShell actorEmail={admin.actorEmail} actorRole={admin.actorRole}>
      <WorkspaceList />
    </OpsShell>
  );
}
```

This gives us:
- **Per-page auth context** — each page can pass actor details to the shell
- **Flexible layouts** — some pages need full-width, others need sidebar panels
- **Server component by default** — no `"use client"` on the shell wrapper

### Centralized theme config

All ops styling lives in a single theme file:

```typescript
// lib/ops/theme.ts
export const opsTheme = {
  colors: { gold: "#d4af37", navy: "#050a18", beige: "#f5f5dc" },
  nav: {
    items: [
      { href: "/ops/god-console", label: "God Console", icon: Crown, group: "core" },
      { href: "/ops/workspaces", label: "Workspaces", icon: Building2, group: "core" },
      // ... 14 total nav items across 6 groups
    ]
  }
};
```

This means:
- Nav items are always in sync across all pages
- Color changes propagate instantly
- New pages just need to be added to the theme config

### Redirect, don't throw

Early on, some pages threw `Error("Unauthorized")` when auth failed. This showed ugly error boundaries to developers who accidentally navigated there. We standardized to:

```typescript
// ✅ Clean redirect
const admin = await requirePlatformAdmin();
if (!admin.ok) redirect("/");

// ❌ Ugly error boundary
const admin = await requirePlatformAdmin();
if (!admin.ok) throw new Error("Unauthorized");
```

## What we monitor

### Health checks

Our health page checks:
- **Database**: Connection pool status, query latency
- **Workers**: Heartbeat freshness (outbox processor, KB indexer)
- **External APIs**: Meta/WhatsApp Graph API availability
- **Queue depth**: Outbox messages waiting to be processed
- **Rate limit headroom**: Redis key counts and expiry status

### Activity dashboard

Every ops action is logged and visualized:
- Who did what, when
- Actor breakdown (pie chart of admin activity)
- Timeline of recent actions
- Filterable by action type, actor, and workspace

## Lessons learned

### 1. Audit everything from day one

Adding audit logging after the fact is painful. We log every mutation at the helper level:

```typescript
await createAuditLog({
  workspace_id: workspaceId,
  actor_id: admin.user.id,
  action: "workspace.suspend",
  before: { status: "active" },
  after: { status: "suspended" },
});
```

### 2. Loading states matter for internal tools too

Internal users are still users. Every ops page has `loading.tsx` and `error.tsx` — 26 pages × 2 boundary files = 52 files, but the experience is night and day.

### 3. Feature flags should be in the ops console, not just env vars

We built a feature flag system directly into the ops console with per-workspace overrides. This lets us:
- Roll out features to specific workspaces
- Kill a feature instantly without deploying
- Test in production with real data

### 4. Standardize auth patterns early

We had 3 different auth patterns across 26 pages before our audit. Standardizing to one pattern (`requirePlatformAdmin()` → redirect on failure) took 18 file changes but prevented future security gaps.

## The result

Our ops console now has:
- **26 pages** across 6 navigation groups
- **25 API routes** powering admin actions
- **11 server actions** for real-time operations
- **14 nav items** all pointing to verified, working pages
- **100% loading/error boundary coverage**
- **Full audit trail** on every mutation

For a team of 2-3 people managing thousands of workspaces, this console is the difference between "let me SSH into the server" and "let me click this button."

## Should you build one?

If you're past 50 paying workspaces, yes. Before that, a simple admin script or database GUI might suffice.

But plan for it early — add audit logging, structured permission checks, and rate limiting to your admin routes from day one. Retrofitting security is always harder than building it in.

---

*Gigaviz is an all-in-one SaaS platform for businesses growing via WhatsApp, Instagram, and social media. Our ops console manages workspaces, entitlements, billing, and support across the entire platform.*
